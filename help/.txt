Here are all the files related to auth handling for my mobile app that I an developing, my password reset link:"@https://gihofdmqjwgkotwxdxms.supabase.co/auth/v1/verify?token=4f0f75626fb41b6e7a9c9572cc442205ad8acd949b47b036352013e7&type=recovery&redirect_to=http://localhost:8081/reset-password " logs me in directly without allowing me to reset my passwordEditLooking at your code and the issue you're experiencing, I can see what's happening with your password reset flow. The problem is with how you're handling the recovery link redirection.
When a user clicks on the reset password link, Supabase is correctly authenticating them and redirecting to your app, but there seems to be an issue in how the recovery flow is being processed between your reset-password.tsx and callback.tsx files.
Here's what's happening:

Your reset link is correctly formed and includes a recovery token
When clicked, Supabase validates the token and attempts to redirect to your app
Instead of showing the password reset form, it's logging you in directly without prompting for a new password

Here's how to fix it:

The issue is primarily in how the hash fragment (#access_token=...) is being handled in your reset-password.tsx file. When Supabase redirects after a successful token verification, it appends auth tokens as hash parameters, but your code might not be capturing them correctly.
Your callback.tsx has some logic for handling the PASSWORD_RECOVERY auth event, but it seems the event isn't being properly passed to your reset-password.tsx component.

Here's a specific fix:
// In reset-password.tsx, modify the useEffect hook that processes hash params:

useEffect(() => {
  async function processHashParams() {
    try {
      // Only run in web environment
      if (typeof window === 'undefined') {
        setIsValidatingSession(false);
        return;
      }
      
      console.log("Processing URL hash for auth tokens");
      
      // Get hash fragment (without the # character)
      const hash = window.location.hash.substring(1);
      
      if (!hash) {
        // Check if we have a session from localStorage (set by callback.tsx)
        if (typeof window !== 'undefined' && localStorage.getItem('hasValidSession') === 'true') {
          const email = localStorage.getItem('passwordResetEmail');
          console.log("Found valid session data in localStorage", email);
          setHasValidSession(true);
          setUserEmail(email);
          setIsValidatingSession(false);
          return;
        }
        
        // No hash parameters - check if we already have a session
        const { data } = await supabase.auth.getSession();
        if (data?.session) {
          console.log("Valid session found without hash params");
          setHasValidSession(true);
          setUserEmail(data.session.user.email);
        } else {
          console.log("No hash params and no valid session");
          setError("Your password reset link has expired. Please request a new one.");
        }
        setIsValidatingSession(false);
        return;
      }
      
      // Rest of your existing code for processing hash params...
    } catch (err) {
      // Error handling...
    }
  }
  
  processHashParams();
}, []);
I recommend combining these approaches for a more robust solution:
// In reset-password.tsx

import React, { useState, useEffect } from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import { useRouter, useLocalSearchParams } from 'expo-router';
import { supabase } from '@/lib/supabase';
import { Text, TextInput, Button, Surface, HelperText } from 'react-native-paper';
import { Lock, ArrowLeft } from 'lucide-react-native';

export default function ResetPasswordScreen() {
  const router = useRouter();
  const params = useLocalSearchParams();
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const [secureTextEntry, setSecureTextEntry] = useState(true);
  const [secureConfirmTextEntry, setSecureConfirmTextEntry] = useState(true);
  const [isValidatingSession, setIsValidatingSession] = useState(true);
  const [hasValidSession, setHasValidSession] = useState(false);
  const [userEmail, setUserEmail] = useState<string | null>(null);
  
  // Handle URL hash and establish session when component mounts
  useEffect(() => {
    async function processAuthState() {
      try {
        // Only run in web environment
        if (typeof window === 'undefined') {
          setIsValidatingSession(false);
          return;
        }
        
        console.log("Processing auth state for password reset");
        
        // Check URL search params first (new approach)
        const urlParams = new URLSearchParams(window.location.search);
        const isPasswordReset = urlParams.get('type') === 'recovery';
        
        if (isPasswordReset) {
          console.log("Detected recovery in URL params");
          
          // We need to wait for Supabase to process the token and establish a session
          const { data } = await supabase.auth.getSession();
          
          if (data?.session) {
            console.log("Valid session established from recovery token");
            setHasValidSession(true);
            setUserEmail(data.session.user.email);
            setIsValidatingSession(false);
            return;
          }
        }
        
        // Check localStorage (set by callback.tsx)
        if (localStorage.getItem('hasValidSession') === 'true') {
          const email = localStorage.getItem('passwordResetEmail');
          const timestamp = localStorage.getItem('passwordResetTimestamp');
          
          // Check if the reset link is still valid (1 hour)
          if (timestamp && (Date.now() - parseInt(timestamp)) < 3600000) {
            console.log("Found valid session data in localStorage", email);
            setHasValidSession(true);
            setUserEmail(email);
            setIsValidatingSession(false);
            return;
          } else {
            // Clear expired data
            localStorage.removeItem('hasValidSession');
            localStorage.removeItem('passwordResetEmail');
            localStorage.removeItem('passwordResetTimestamp');
          }
        }
        
        // Get hash fragment (without the # character)
        const hash = window.location.hash.substring(1);
        
        if (hash) {
          // Parse hash params
          const params = new URLSearchParams(hash);
          const accessToken = params.get('access_token');
          const refreshToken = params.get('refresh_token');
          const type = params.get('type');
          
          console.log("Hash params type:", type);
          
          // If we have recovery tokens, set the session
          if (accessToken && type === 'recovery') {
            console.log("Found recovery tokens, setting session");
            
            // Set the session with the tokens
            const { data, error: sessionError } = await supabase.auth.setSession({
              access_token: accessToken,
              refresh_token: refreshToken || '',
            });
            
            if (sessionError) {
              console.error("Error setting session:", sessionError);
              throw sessionError;
            }
            
            if (data?.session) {
              console.log("Successfully established session from hash");
              setHasValidSession(true);
              setUserEmail(data.session.user.email);
              
              // Store in localStorage for redundancy
              localStorage.setItem('hasValidSession', 'true');
              localStorage.setItem('passwordResetEmail', data.session.user.email || '');
              localStorage.setItem('passwordResetTimestamp', Date.now().toString());
              
              // Clean the URL by removing the hash
              if (window.history && window.history.replaceState) {
                window.history.replaceState({}, document.title, window.location.pathname);
              }
              
              setIsValidatingSession(false);
              return;
            }
          }
        }
        
        // Last resort: check if we have a valid session already
        const { data } = await supabase.auth.getSession();
        if (data?.session) {
          console.log("Found existing valid session");
          setHasValidSession(true);
          setUserEmail(data.session.user.email);
        } else {
          console.log("No valid session found through any method");
          setError("Your password reset link has expired or is invalid. Please request a new one.");
        }
      } catch (err) {
        console.error("Error processing auth state:", err);
        setError("An error occurred while processing your reset link.");
      } finally {
        setIsValidatingSession(false);
      }
    }
    
    // Set up auth state change listener
    const { data: authListener } = supabase.auth.onAuthStateChange((event, session) => {
      console.log(`Auth state changed: ${event}`);
      
      if (event === 'PASSWORD_RECOVERY') {
        console.log('Password recovery event detected');
        
        if (session?.user?.email) {
          setHasValidSession(true);
          setUserEmail(session.user.email);
          setIsValidatingSession(false);
          
          // Store in localStorage
          localStorage.setItem('hasValidSession', 'true');
          localStorage.setItem('passwordResetEmail', session.user.email);
          localStorage.setItem('passwordResetTimestamp', Date.now().toString());
        }
      }
    });
    
    processAuthState();
    
    return () => {
      if (authListener && authListener.subscription) {
        authListener.subscription.unsubscribe();
      }
    };
  }, []);

  async function handleResetPassword() {
    // Validate form fields
    if (!password || !confirmPassword) {
      setError('Please fill in all fields');
      return;
    }

    if (password !== confirmPassword) {
      setError('Passwords do not match');
      return;
    }

    if (password.length < 6) {
      setError('Password must be at least 6 characters');
      return;
    }

    // Reset state
    setError(null);
    setLoading(true);

    try {
      // Update password using the existing session
      const { error } = await supabase.auth.updateUser({ password });
      
      if (error) {
        throw error;
      }
      
      // Success!
      setSuccessMessage('Your password has been updated successfully!');
      
      // Clear localStorage data
      localStorage.removeItem('hasValidSession');
      localStorage.removeItem('passwordResetEmail');
      localStorage.removeItem('passwordResetTimestamp');
      
      // Wait a moment before redirecting to login
      setTimeout(() => {
        // Sign out first to clear the session
        supabase.auth.signOut().then(() => {
          router.replace('/login');
        });
      }, 2000);
      
    } catch (error: any) {
      console.error("Password update error:", error);
      
      // Handle specific errors
      if (error.message?.includes('expired')) {
        setError('Your password reset link has expired. Please request a new one.');
      } else {
        setError(error.message || 'Failed to update password');
      }
    } finally {
      setLoading(false);
    }
  }

  // Handle requesting a new password reset
  function handleRequestNewReset() {
    router.replace('/forgot-password');
  }

  // Show loading state
  if (isValidatingSession) {
    return (
      <View style={[styles.container, styles.centered]}>
        <Text style={{ color: '#fff' }}>Verifying your password reset link...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Surface style={styles.formContainer} elevation={2}>
        <Text variant="headlineMedium" style={styles.title}>
          {hasValidSession ? 'Create New Password' : 'Reset Link Expired'}
        </Text>
        
        <Text variant="bodyLarge" style={styles.subtitle}>
          {hasValidSession 
            ? 'Enter your new password below' 
            : 'Your reset link has expired or is invalid'}
        </Text>

        {error && (
          <HelperText type="error" visible={!!error}>
            {error}
          </HelperText>
        )}

        {successMessage && (
          <HelperText type="info" visible={!!successMessage} style={styles.successMessage}>
            {successMessage}
          </HelperText>
        )}
        
        {hasValidSession ? (
          <>
            {userEmail && (
              <Text style={styles.emailInfo}>
                Setting new password for: <Text style={styles.emailHighlight}>{userEmail}</Text>
              </Text>
            )}
            
            <TextInput
              mode="outlined"
              label="New Password"
              value={password}
              onChangeText={(text) => {
                setPassword(text);
                setError(null);
              }}
              style={styles.input}
              secureTextEntry={secureTextEntry}
              left={<TextInput.Icon icon={() => <Lock size={20} color="#888" />} />}
              right={<TextInput.Icon icon={secureTextEntry ? "eye" : "eye-off"} onPress={() => setSecureTextEntry(!secureTextEntry)} />}
            />
            
            <TextInput
              mode="outlined"
              label="Confirm New Password"
              value={confirmPassword}
              onChangeText={(text) => {
                setConfirmPassword(text);
                setError(null);
              }}
              style={styles.input}
              secureTextEntry={secureConfirmTextEntry}
              left={<TextInput.Icon icon={() => <Lock size={20} color="#888" />} />}
              right={<TextInput.Icon icon={secureConfirmTextEntry ? "eye" : "eye-off"} onPress={() => setSecureConfirmTextEntry(!secureConfirmTextEntry)} />}
            />
            
            <Button 
              mode="contained" 
              onPress={handleResetPassword}
              style={styles.button}
              loading={loading}
              disabled={loading}
            >
              Update Password
            </Button>
          </>
        ) : (
          <Button 
            mode="contained" 
            onPress={handleRequestNewReset}
            style={styles.button}
          >
            Request New Reset Link
          </Button>
        )}
        
        <TouchableOpacity 
          onPress={() => router.push('/login')}
          style={styles.backButton}
        >
          <ArrowLeft size={20} color="#888" />
          <Text style={styles.backButtonText}>Back to Login</Text>
        </TouchableOpacity>
      </Surface>
    </View>
  );
}
Now, let's update your callback handler to better coordinate with the reset password flow:
import React, { useEffect, useState } from 'react';
import { View, StyleSheet, ActivityIndicator } from 'react-native';
import { Text } from 'react-native-paper';
import { useRouter, useLocalSearchParams } from 'expo-router';
import { supabase } from '@/lib/supabase';

export default function AuthCallbackPage() {
  const router = useRouter();
  const params = useLocalSearchParams();
  const type = params.type as string;
  const error = params.error as string;
  const error_description = params.error_description as string;
  const [isProcessing, setIsProcessing] = useState(true);
  const [errorState, setErrorState] = useState<string | null>(null);

  useEffect(() => {
    const processCallback = async () => {
      try {
        console.log('Auth callback processing started');
        console.log('Params:', JSON.stringify(params));
        
        // Handle error if present
        if (error) {
          console.error(`Auth error: ${error}`, error_description);
          setErrorState(error_description?.toString() || 'Authentication error');
          setTimeout(() => {
            router.replace({
              pathname: '/login',
              params: { error: error_description ||